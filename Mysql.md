- 共享锁和排他锁也叫读锁和写锁, 写锁相比于读锁有更高的优先级, 因此一个写锁请求可能会插入到读锁队列的前面

- 锁的弊端, 加锁需要消耗资源, 锁的各种操作, 包括获得锁, 检查锁是否解除, 释放锁等, 都会增加系统的开销, 如果系统花费大量时间来管理锁, 而不是存取数据, 那么系统的性能可能会受此影响

- 表锁: 表锁是`Mysql`中最基本的锁, 并且是开销最小的锁, 它会锁定整张表, 一个用户在对表进行写操作( 插入, 更新, 删除 ) 前需要获得写锁, 这会阻塞其他用户对该表的所有读写操作, 只有在没有写锁的情况下, 其他的用户才能获得读锁, 读锁是互相不阻塞的

- 行级锁可以最大程度的支持并发处理 ( 同时也带来了最大的锁开销 )

- 事务是一组原子性的`SQL`查询, 如果数据库引擎能够成功地对数据库应用该组查询的全部语句, 那么就执行该组查询, 事务内的语句要么全部执行成功, 要么全部执行失败

- 隔离级别, `SQL`定义了四种隔离级别, 较低级别的隔离通常可以执行更高的并发

  | 未提交读                                                     | 提交读       | 可重复读                                                     | 可串行化                                                     |
  | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 事务中的修改, 即使没有提交,对其它事务, 也都是可见的, 这称为脏读 | 默认隔离级别 | 该级别保证了在同一个事务中多次读取同样记录的结果是一致的, 但无法解决幻读的问题 | 最高隔离级别, 它强制事务串行化执行, 它会在每一行读取的数据上都加锁, 所以可能导致大量的超时和锁争用问题 |

- `show table status like 'table_name'` 命令查看数据表的相关信息

- `MyISAM`引擎最典型的性能问题是表锁问题, 如果发现所有的查询都长期处于 `Locked` 状态, 那么表锁可能就是最大的罪魁祸首

- `show full processlist` 命令查看线程级相关信息

- `MySql`可以为整数指定宽度, 例如`INT(11)`, 对大多数应用这是没有意义的 : 它不会限制值的合法范围, 只是规定了`MySql`的一些交互工具用来显示字符的个数, 对于存储和计算来说, `INT(1)` 和 `INT(20)` 是相同的

- 货币可选用`decimal`类型来存储

- `varchar`可用来存储可变长度的字段, 它需要1或2个额外字节记录字符串的长度, 由于是可变长度的所以update时可能使得行变得比原来更长, 这导致需要做额外的工作

- `char`用来存储定长的字段, 当存储的数据长度不够时会填充空格以达到指定长度

- 使用`varchar(5)`和`varchar(200)`存储`hello`的空间开销是一样的, 那么使用更短的列有什么优势呢, 更长的列会消耗更多的内存, 因为`MySql`通常会分配固定大小的内存来保存内部值

- 什么是索引, 索引是用于快速找到记录的一种数据结构

- 聚簇索引并不是一种单独的索引, 而是一种数据存储方式, `InnoDB`的聚簇索引实际上在同一个结构中保存了

  `B-Tree`索引和数据行, 当表有聚簇索引时, 它的数据行实际存放在索引的叶子页中, 一个表只能有一个聚簇索引
  
- 聚簇索引的优点, 1: 数据访问更快, 聚簇索引将索引和数据保存在同一个B-Tree中,因此获取数据通常比非聚簇索引快, 2: 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

- 聚簇索引中, 二级索引访问需要两次索引查找,  因为二级索引叶子节点保存的不是行指针而是行的主键, 这种查找方式通常也叫回表, 如何避免回表可采用覆盖索引的方式

- 在`InnoDB`中主键为什么要尽量选用自增的数字而不是`uuid`, 因为自增数字主键是有序的, 插入数据时可以按顺序插入, 而`uuid`是无序的插入数据时不能按顺序直接写入磁盘, 还会造成页分裂, 而页分裂会造成行移动和碎片化

- 在`Linux`中`MySQL`配置文件一般在`/etc/my.cnf`或者`/etc/mysql/my.cnf`

- 查找MySQL配置文件

  ```
  which mysql
  在mysql命令行模式下执行如下命令
  --verbose --help |grep -A 1 'Default options'
  ```


- 查看`MySQL`全局配置命令`show global variables`
- 查看当前`innodb`引擎的状态信息 `show engine innodb status`
- `MySQL`并不会像我们一样去操作行数据，而是抽象出来一个一个的数据页概念，每个数据页的大小默认是 `16KB`,  即使我们只需要访问一个页的一条记录,  那也需要先把整个页的数据加载到内存中, 通常`mysql`的预读机制还会导致获取目标页的相邻页
-  `MySQL`的所有的增删改的操作都是在 `Buffer Pool` 中执行的 
-  缓冲池中默认的缓存页大小和在磁盘上默认的页大小是一样的，一般是`16KB`。 
-   `MySQL`在执行增删改首先会定位到这条数据所在的数据页，然后会将**数据所在的数据页**加载到 `Buffer Pool` 中 , 然后在缓冲池中进行具体得操作
-  `Buffer Pool` 一次只能允许一个线程来操作，因为`MySQL` 为了保证数据的一致性，操作的时候必须给缓存池加锁，一次只能有一个线程获取到锁。 因为所有操作都是在内存中进行所以效率很高,  但是串行执行会阻塞其它线程， 因此`Buffer Pool` 是可以有多个的，可以通过 `MySQL`的配置文件来配置
-  如果一张表里有很多大字段, 最好是把它们组合起来单独存到一个列里面, 比如说用`XML` 或者 `JSON`格式存储, 这让所有大字段共享一个扩展存储空间, 这比每个字段用自己的页要好,
-  在`MySQL`的设定中，单行数据最大能存储`65535 byte`  当列的类型为`VARCHAR`、 `VARBINARY`、 `BLOB`、`TEXT`时， 当列长度达到`768byte`后，会将该列的前`768byte`当作prefix存放在行中，多出来的数据溢出存放到溢出页中，然后通过一个偏移量指针将两者关联起来，这就是行溢出机制。  
-  配置大量内存的原因不是因为可以在内存中保存大量数据, 而是避免磁盘I/O, 因为磁盘I/O比在内存中访问数据要慢得多
-  `vmstat` 和 `iostat` 命令用来观察服务器详细状态, 可使用`dstat`命令代替`vmstat`  能输出比 `vmstat` 更加：美观，整洁，强大的内容 

