#### 中断和异常

------

- 中断是为了实现多道程序并发执行引入的一种机制, 发生了中断, 就意味着需要操作系统介入, 开展工作, 由于操作系统的管理工作 (比如进程切换, 分配I/O设备等) 需要使用特权指令,  因此**CPU**要从用户态转为核心态,  中断可以使CPU从用户态切换为核心态,  使操作系统获得计算机的控制权.  有了中断, 才能实现多道程序的并发执行
- 中断本质上是一种特殊的电信号,由硬件设备发向CPU,处理器接收到中断后,会马上向操作系统反映此信号的到来
- 中断是由硬件引起的而不是软件
- 一个设备的中断处理程序是它设备驱动的一部分,设备驱动程序是用于对设备进行管理的内核代码
- 中断发生就意味着需要操作系统介入, 开展管理工作
- 当中断发生时, CPU立即进入核心态
- 进程从用户态切换到核心态有两种方式, 系统调用 和 中断
- 中断机制, 当硬件设备想和系统通信的时候,它首先要发出一个异步的中断信号,去打断处理器的执行,中断通常对应着一个中断号,内核通过这个中断号查找相应的中断服务程序,并调用这个程序响应和处理中断



#### 系统调用

------

- 系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务 
- 系统调用会使操作系统从用户态切换到核心态
- 应用程序通过**系统调用**来操作计算机资源。计算机中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
- 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行 
- 高级语言最后会被编译成汇编语言, 系统调用的另一个好处是, 将操作系统调用硬件资源的复杂操作, 隐藏和封装起来, 从而为应用程序提供一个简单易用的接口



#### 进程

------

- 什么是进程 ? 进程是程序运行的实例, 进程是程序的一次执行过程, 

- 线程是CPU调度的单位, 进程是资源分配的单位

- 进程是系统进行资源分配和调度的一个独立单元

- 子进程与父进程的关系, 子进程是父进程的一个副本, 在只读访问的情况下父进程和子进 程可以共用同一内存页, 直到其中一个进程向某内存页面写入数据之前, 这称之为写时复制

- 进程的几种状态及其转换 ,就绪态, 运行态, 阻塞态

- 进程分为用户态和核心态(**核心态进程管理着所有进程之间共享的资源，例如文件系统空间**), 当用户态进程想要访问系统数据或功能则必须切换到核心态,

- 进程运行所需的所有状态信息,可以称为进程的上下文

- 进程从用户态切换到核心态有两种方式, 系统调用 和 中断

- 进程间通信机制（信号量、消息队列、共享内存, 管道）, 通过共享内存实现进程通信时,要互斥的访问共享内存空间, 通过管道实现进程通信,一个管道只能实现半双工通信,同一时间只能向管道写数据或者读数据,两者不能同时操作

- 进程调度是操作系统中最基本的一种调度,

- 进程在操作系统内核程序临界区中不能进行调度与切换

- 进程调度分为**抢占式**和**非抢占式**, 非抢占式只允许进程主动放弃处理器, 在运行过程中即便有更紧迫的任务到达, 当前进程依然会继续使用处理器, 直到该进程终止或主动要求进入阻塞态.  抢占式当一个进程正在运行时,如果有更紧迫的进程需要使用处理器, 则立即暂停执行当前进程, 转而将处理器分配给更重要紧迫的哪个进程

- 进程互斥,  某段时间内**只允许一个进程使用**的资源称为**临界资源** ,  而每个进程访问临界资源的那段**程序代码称为临界区** , 当进程访问临界资源时要实现进程的**互斥**访问

- 在多道程序环境下，进程之间在单核CPU下是并发执行的，在多核CPU中可并行执行。所以进程之间存在相互制约，为了协调这种制约，实现资源共享和进程协作，我们引入了[进程同步](https://zhuanlan.zhihu.com/p/31630912)、进程互斥、进程通信。 

-  时间片: 时间片即TimeSlice，指的是**分时复用**过程中每个进程允许持续运行的**最大时间配额单位**。也就是说，如果A进程持续运行了一个TimeSlice，那么它必须考虑让出CPU资源给B进程 

-  在多核处理器的计算机上，进程的数量通常也是远远多于处理器数量的。因此，宏观上并行运行的多个进程在微观上往往属于**分时复用**。进程调度的本质是**怎么样让进程更好地分时复用处理器资源**。概括地说，进程调度包括**调度策略**和**进程切换**两个重要话题 , 针对一个处理器来说，分时复用无非就是A进程的时间配额用完以后换到B进程的事情。在这个场景下，“如何选择B进程”就是调度策略，“如何运行B进程”就是进程切换。 

  

#### 线程

------

- 线程可以称为轻量级的进程,  一个进程可能由若干线程组成，这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。
- 从内核角度来说并没有线程这个概念, linux把所有的线程都当做进程来实现.内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程,相反线程仅仅被视为一个与其它进程共享某些资源的进程
- 线程是一个基本的cpu执行单元, 也是程序执行流的最小单位
- 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。但是不能独立运行，必须依存在应用程序中，由应用程序提供多个线程执行控制。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。线程是处于动态条件下由操作系统维护的系统资源管理实体
-  如果同一进程内的线程切换, 则不需要切换进程上下文, 系统开销相对于进程切换开销更小
- 线程也有就绪, 运行, 阻塞三种状态
- 线程几乎不拥有系统资源, 它们共享进程的资源
- 不同进程内的线程切换, 会引起进程切换

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

#### 锁

------

- 什么是竞态条件: **几个进程在访问资源时彼此干扰的情况通常称之为竞态条件**,在对分布式应用编程时，这
  种情况是一个主要的问题，因为竞态条件无法通过系统的试错法检测。相反，只有彻底研究源代码（深入了
  解各种可能发生的代码路径）并通过敏锐的直觉，才能找到并消除竞态条件。
- 临界区, 临界资源: 在计算机中，某段时间内**只允许一个进程使用**的资源称为临界资源  比如打印机，共享变量等等。而每个进程访问临界资源的那段**程序代码称为临界区** 
- 什么是原子操作, 原子操作指的是在执行过程中不能被**中断**的操作, 执行过程中，出现上下文切换行为，比如任务切换，**中断处理**等。都会影响原子操作的原子性。因此需要自旋锁spinlock[[1\]](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Spinlock)来保证操作指令序列不会在执行的中途受干扰 
- 操作系统引入了锁机制。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。 
- 所谓的锁，可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。 
- 死锁: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁, 这些永远在互相等待的进程称为死锁进程. 